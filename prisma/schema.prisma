// This is your Prisma schema file
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== USER MANAGEMENT ====================
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String
  role      Role     @default(CHECKER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  websitesCreated  Website[]         @relation("WebsiteCreator")
  websitesChecked  Website[]         @relation("WebsiteChecker")
  registrationLogs RegistrationLog[]
  websiteStats     WebsiteStats[]
  gmails           Gmail[]
  gmailUsages      GmailUsage[]
  tools            Tool[]

  @@map("users")
}

enum Role {
  ADMIN     // Quản trị viên - toàn quyền
  MANAGER   // Quản lý - quản lý websites và users
  DEV       // Developer - phát triển tool
  CTV       // Cộng tác viên - thêm và test website
  CHECKER   // Kiểm tra viên - kiểm tra website
}

// ==================== WEBSITE/DOMAIN MANAGEMENT ====================
model Website {
  id          String         @id @default(uuid())
  domain      String         @unique
  types       WebsiteType[]  @default([ENTITY])
  status      WebsiteStatus  @default(NEW)
  notes       String?        @db.Text // Notes from CHECKER (combined note and error details)

  // Metrics stored as JSONB - flexible for adding new metrics
  metrics     Json?          @db.JsonB

  // Tracking who created and last checked
  createdBy   String?        // User who created this website
  checkerId   String?        // Last person who checked/updated

  // Additional info
  priority    Int            @default(0) // Higher number = higher priority
  category    String?        // Group websites by category
  tags        String[]       @default([]) // Tags for filtering

  // Timestamps
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?     // Soft delete - null means active, date means deleted
  lastTestedAt DateTime?     // Last time tested/checked
  lastUsedAt   DateTime?     // Last time used by tool
  lastCheckedAt DateTime?    // Last time someone checked/noted

  // Relations
  creator          User?                @relation("WebsiteCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  checker          User?                @relation("WebsiteChecker", fields: [checkerId], references: [id], onDelete: SetNull)
  logs             RegistrationLog[]
  stats            WebsiteStats[]
  allocationItems  AllocationItem[]

  @@index([types])
  @@index([status])
  @@index([domain])
  @@index([createdBy])
  @@index([checkerId])
  @@index([createdAt])
  @@index([deletedAt])
  // Composite indexes for common queries
  @@index([status, deletedAt])
  @@index([deletedAt, status])
  @@index([deletedAt, createdAt])
  @@map("websites")
}

enum WebsiteStatus {
  NEW           // Mới thêm vào hệ thống
  CHECKING      // Đang trong quá trình CTV check
  HANDING       // Đội CTV test tay
  PENDING       // Chờ dev phát triển trên tool
  RUNNING       // Đã sẵn sàng vào hệ thống
  ERROR         // Lỗi
  MAINTENANCE   // Đang bảo trì
}

enum WebsiteType {
  ENTITY        // Entity
  BLOG2         // Blog 2.0
  PODCAST       // Podcast
  SOCIAL        // Social
  GG_STACKING   // GG Stacking
}

enum CheckType {
  MANUAL
  AUTO
  SCHEDULED
}

// ==================== REGISTRATION LOGS ====================
model RegistrationLog {
  id          String    @id @default(uuid())
  websiteId   String
  userId      String?   // Who triggered this (if manual)
  
  // Registration attempt details
  isSuccess   Boolean
  errorCode   String?
  errorMessage String?  @db.Text
  stackTrace  String?   @db.Text
  
  // Performance metrics
  startTime   DateTime
  endTime     DateTime?
  duration    Int?      // Duration in milliseconds
  
  // Request/Response data
  requestData Json?     @db.JsonB
  responseData Json?    @db.JsonB
  
  // Tool information
  toolVersion String?
  toolName    String?
  ipAddress   String?
  userAgent   String?
  
  // Metadata
  metadata    Json?     @db.JsonB
  
  createdAt   DateTime  @default(now())
  
  // Relations
  website     Website   @relation(fields: [websiteId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id])
  
  @@index([websiteId])
  @@index([isSuccess])
  @@index([createdAt])
  @@index([startTime])
  @@map("registration_logs")
}

// ==================== STATISTICS ====================
model WebsiteStats {
  id          String    @id @default(uuid())
  websiteId   String
  userId      String?   // Stats per user (optional, null = system-level stats)

  // Time period for stats
  periodType  PeriodType
  periodStart DateTime
  periodEnd   DateTime

  // Success metrics
  totalAttempts    Int      @default(0)
  successCount     Int      @default(0)
  failureCount     Int      @default(0)
  successRate      Float    @default(0)

  // Performance metrics
  avgDuration      Float?   // Average duration in milliseconds
  minDuration      Float?
  maxDuration      Float?

  // Error tracking
  errorTypes       Json?    @db.JsonB // {"error_type": count}

  // Additional metrics
  metrics          Json?    @db.JsonB

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  website     Website   @relation(fields: [websiteId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id])

  // Note: Using separate index instead of unique constraint to support null userId
  @@index([websiteId, periodType, periodStart])
  @@index([websiteId])
  @@index([periodStart, periodEnd])
  // Additional composite indexes for statistics
  @@index([userId, periodType])
  @@index([periodType, periodStart])
  @@map("website_stats")
}

enum PeriodType {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  CUSTOM
}

// ==================== SYSTEM SETTINGS ====================
model SystemSetting {
  id        String   @id @default(uuid())
  key       String   @unique
  category  String?
  value     Json     @db.JsonB
  description String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("system_settings")
}

// ==================== AUDIT LOG ====================
model AuditLog {
  id          String   @id @default(uuid())
  userId      String?
  action      String   // CREATE, UPDATE, DELETE, etc.
  entity      String   // Website, User, etc.
  entityId    String?
  oldValues   Json?    @db.JsonB
  newValues   Json?    @db.JsonB
  ipAddress   String?
  userAgent   String?

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([entity, entityId])
  @@index([createdAt])
  // Composite indexes for statistics queries
  @@index([userId, createdAt])
  @@index([entity, createdAt])
  @@index([action, entity, createdAt])
  // Index for filtering by entityId with date range (used in getCTVIncomeStats, getCTVStatusChanges)
  @@index([entityId, createdAt])
  @@index([entity, action, entityId, createdAt])
  @@map("audit_logs")
}

// ==================== WEBSITE ALLOCATION ====================
// Batch phân bổ website cho mỗi entity_request từ MySQL
model AllocationBatch {
  id                  String              @id @default(uuid())
  externalRequestId   String              // ID của entity_request bên MySQL
  batchNumber         Int                 // Số thứ tự batch (1, 2, 3...)

  // Allocation info
  targetCount         Int                 // Số website cần phân bổ trong batch này
  allocatedCount      Int                 @default(0)
  highTrafficCount    Int                 @default(0) // Số website traffic cao
  lowTrafficCount     Int                 @default(0) // Số website traffic thấp

  // Status
  status              AllocationBatchStatus @default(PENDING)

  // Timing
  startedAt           DateTime?
  completedAt         DateTime?

  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Relations
  items               AllocationItem[]

  @@unique([externalRequestId, batchNumber])
  @@index([externalRequestId])
  @@index([status])
  @@index([createdAt])
  @@map("allocation_batches")
}

enum AllocationBatchStatus {
  PENDING     // Chờ phân bổ
  PROCESSING  // Đang phân bổ
  COMPLETED   // Hoàn thành phân bổ
  FAILED      // Thất bại
}

// Chi tiết từng website được phân bổ
model AllocationItem {
  id              String              @id @default(uuid())
  batchId         String
  websiteId       String
  domain          String              // Lưu domain để dễ insert vào MySQL entity_link

  // Allocation tracking
  trafficType     TrafficType         // HIGH hoặc LOW
  priorityScore   Float               @default(0) // Score dùng để sort (based on success rate)

  // Result tracking (sync từ entity_link)
  status          AllocationItemStatus @default(PENDING)
  resultSyncedAt  DateTime?           // Khi sync kết quả từ MySQL

  // Error info (if failed)
  errorCode       String?
  errorMessage    String?

  allocatedAt     DateTime            @default(now())
  completedAt     DateTime?

  // Relations
  batch           AllocationBatch     @relation(fields: [batchId], references: [id], onDelete: Cascade)
  website         Website             @relation(fields: [websiteId], references: [id], onDelete: Cascade)

  @@index([batchId])
  @@index([websiteId])
  @@index([status])
  @@index([allocatedAt])
  @@map("allocation_items")
}

enum TrafficType {
  HIGH    // >= 50k traffic
  LOW     // < 50k traffic
}

enum AllocationItemStatus {
  PENDING     // Đã phân bổ, chờ chạy
  RUNNING     // Đang chạy
  SUCCESS     // Thành công
  FAILED      // Thất bại
  SKIPPED     // Bỏ qua
  CANCELLED   // Bị hủy (chưa chạy, không tính vào success rate)
}

// ==================== DAILY ALLOCATION TRACKING ====================
// Track số lần website được phân bổ trong ngày
model DailyAllocation {
  id              String    @id @default(uuid())
  websiteId       String
  date            DateTime  @db.Date // Ngày (không có giờ)

  allocationCount Int       @default(0) // Số lần được phân bổ trong ngày
  successCount    Int       @default(0)
  failureCount    Int       @default(0)

  updatedAt       DateTime  @updatedAt

  @@unique([websiteId, date])
  @@index([websiteId])
  @@index([date])
  @@map("daily_allocations")
}

// ==================== SYSTEM ALERTS ====================
// Alert khi có vấn đề (timeout, tool offline, etc.)
model SystemAlert {
  id            String        @id @default(uuid())
  type          AlertType
  severity      AlertSeverity @default(WARNING)

  title         String
  message       String        @db.Text

  // Related entities
  entityType    String?       // Request, Tool, Website, etc.
  entityId      String?

  // Status
  isResolved    Boolean       @default(false)
  resolvedAt    DateTime?
  resolvedBy    String?

  metadata      Json?         @db.JsonB

  createdAt     DateTime      @default(now())

  @@index([type])
  @@index([severity])
  @@index([isResolved])
  @@index([createdAt])
  @@map("system_alerts")
}

enum AlertType {
  REQUEST_TIMEOUT     // Request quá deadline
  TOOL_OFFLINE        // Tool offline
  ALLOCATION_FAILED   // Phân bổ thất bại
  LOW_SUCCESS_RATE    // Tỷ lệ thành công thấp
  NO_AVAILABLE_TOOLS  // Không còn tool khả dụng
  SYSTEM_ERROR        // Lỗi hệ thống
}

enum AlertSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

// ==================== GMAIL MANAGEMENT ====================
model Gmail {
  id              String       @id @default(uuid())
  email           String       @unique
  password        String
  appPassword     String?      @map("app_password")
  twoFA           String?      @map("2fa")
  recoveryEmail   String?      @map("recovery_email")

  // Owner - người sở hữu gmail này (người đầu tiên sử dụng)
  ownerId         String?      @map("owner_id")
  owner           User?        @relation(fields: [ownerId], references: [id], onDelete: SetNull)

  // Status
  status          GmailStatus  @default(SUCCESS)

  // Timestamps
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  deletedAt       DateTime?    // Soft delete

  // Relations
  usages          GmailUsage[]

  @@index([email])
  @@index([ownerId])
  @@index([status])
  @@index([deletedAt])
  @@map("gmails")
}

// Track lịch sử sử dụng Gmail (mỗi lần export)
model GmailUsage {
  id          String   @id @default(uuid())
  gmailId     String   @map("gmail_id")
  userId      String   @map("user_id")

  // Timestamps
  usedAt      DateTime @default(now())

  // Relations
  gmail       Gmail    @relation(fields: [gmailId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([gmailId])
  @@index([userId])
  @@index([usedAt])
  @@map("gmail_usages")
}

enum GmailStatus {
  SUCCESS     // Thành công
  FAILED      // Thất bại
}

// ==================== TOOL MANAGEMENT ====================
model Tool {
  id              String          @id @default(uuid())

  // User relationship
  userId          String?         @map("user_id")
  user            User?           @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Tool info
  idTool          String          @map("id_tool")
  threadNumber    Int             @default(1) @map("thread_number")

  // Type & Status
  type            ToolType        @default(INDIVIDUAL)
  status          ToolStatus      @default(RUNNING)
  service         ToolService     @default(ENTITY)

  // Time tracking
  estimateTime    Int?            @map("estimate_time") // Thời gian ước tính (phút/giây)

  // Customer info
  customerType    String?         @map("customer_type")

  // Timestamps
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  deletedAt       DateTime?       // Soft delete

  @@index([userId])
  @@index([idTool])
  @@index([type])
  @@index([status])
  @@index([service])
  @@index([deletedAt])
  @@map("tools")
}

enum ToolType {
  INDIVIDUAL    // Cá nhân
  GLOBAL        // Toàn cục
  CANCEL        // Hủy
  RE_RUNNING    // Chạy lại
}

enum ToolStatus {
  RUNNING       // Đang chạy
  DIE           // Chết/Dừng
}

enum ToolService {
  ENTITY          // Entity
  SOCIAL          // Social
  INDEX           // Index
  GOOGLE_STACKING // Google Stacking
  BLOG            // Blog
  PODCAST         // Podcast
}

// ==================== PROXY MANAGEMENT ====================
model Proxy {
  id              String          @id @default(uuid())

  // Connection info
  ip              String
  port            Int
  username        String?
  password        String?

  // Type & Protocol
  type            ProxyType       @default(IPV4_STATIC)
  protocol        ProxyProtocol   @default(HTTP)

  // Services this proxy is used for
  services        ProxyServiceType[] @default([])

  // Status & Health
  status          ProxyStatus     @default(UNKNOWN)
  lastCheckedAt   DateTime?       @map("last_checked_at")
  responseTime    Int?            @map("response_time") // in milliseconds
  failCount       Int             @default(0) @map("fail_count")

  // Location
  country         String?         @db.VarChar(2)

  // Notes
  note            String?         @db.Text

  // Timestamps
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@unique([ip, port])
  @@index([type])
  @@index([protocol])
  @@index([status])
  @@index([services])
  @@index([createdAt])
  @@map("proxies")
}

enum ProxyType {
  IPV4_STATIC     // Proxy IPv4 tĩnh
  IPV6_STATIC     // Proxy IPv6 tĩnh
  SOCKS5          // Proxy SOCKS5
  ROTATING        // Proxy xoay
}

enum ProxyProtocol {
  HTTP
  HTTPS
  SOCKS4
  SOCKS5
}

enum ProxyStatus {
  ACTIVE          // Hoạt động tốt
  DEAD            // Chết/Không hoạt động
  CHECKING        // Đang kiểm tra
  UNKNOWN         // Chưa kiểm tra
}

enum ProxyServiceType {
  ENTITY          // Entity
  BLOG_2_0        // Blog 2.0
  PODCAST         // Podcast
  SOCIAL          // Social
  GG_STACKING     // GG Stacking
}