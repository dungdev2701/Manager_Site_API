// This is your Prisma schema file
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== USER MANAGEMENT ====================
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String
  role      Role     @default(CHECKER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  websitesCreated  Website[]         @relation("WebsiteCreator")
  websitesChecked  Website[]         @relation("WebsiteChecker")
  registrationLogs RegistrationLog[]
  websiteStats     WebsiteStats[]
  gmails           Gmail[]
  gmailUsages      GmailUsage[]
  tools            Tool[]
  assignedRequests ServiceRequest[]

  @@map("users")
}

enum Role {
  ADMIN     // Quản trị viên - toàn quyền
  MANAGER   // Quản lý - quản lý websites và users
  DEV       // Developer - phát triển tool
  CTV       // Cộng tác viên - thêm và test website
  CHECKER   // Kiểm tra viên - kiểm tra website
}

// ==================== WEBSITE/DOMAIN MANAGEMENT ====================
model Website {
  id          String         @id @default(uuid())
  domain      String         @unique
  types       WebsiteType[]  @default([ENTITY])
  status      WebsiteStatus  @default(NEW)
  notes       String?        @db.Text // Notes from CHECKER (combined note and error details)

  // Metrics stored as JSONB - flexible for adding new metrics
  metrics     Json?          @db.JsonB

  // Tracking who created and last checked
  createdBy   String?        // User who created this website
  checkerId   String?        // Last person who checked/updated

  // Additional info
  priority    Int            @default(0) // Higher number = higher priority
  category    String?        // Group websites by category
  tags        String[]       @default([]) // Tags for filtering

  // Timestamps
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?     // Soft delete - null means active, date means deleted
  lastTestedAt DateTime?     // Last time tested/checked
  lastUsedAt   DateTime?     // Last time used by tool
  lastCheckedAt DateTime?    // Last time someone checked/noted

  // Relations
  creator          User?                @relation("WebsiteCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  checker          User?                @relation("WebsiteChecker", fields: [checkerId], references: [id], onDelete: SetNull)
  logs             RegistrationLog[]
  stats            WebsiteStats[]
  allocationItems  AllocationItem[]

  @@index([types])
  @@index([status])
  @@index([domain])
  @@index([createdBy])
  @@index([checkerId])
  @@index([createdAt])
  @@index([deletedAt])
  // Composite indexes for common queries
  @@index([status, deletedAt])
  @@index([deletedAt, status])
  @@index([deletedAt, createdAt])
  @@map("websites")
}

enum WebsiteStatus {
  NEW           // Mới thêm vào hệ thống
  CHECKING      // Đang trong quá trình CTV check
  HANDING       // Đội CTV test tay
  PENDING       // Chờ dev phát triển trên tool
  RUNNING       // Đã sẵn sàng vào hệ thống
  ERROR         // Lỗi
  MAINTENANCE   // Đang bảo trì
}

enum WebsiteType {
  ENTITY        // Entity
  BLOG2         // Blog 2.0
  PODCAST       // Podcast
  SOCIAL        // Social
  GG_STACKING   // GG Stacking
  ENTITY_SOCIAL // Entity Social
}

enum CheckType {
  MANUAL
  AUTO
  SCHEDULED
}

// ==================== REGISTRATION LOGS ====================
model RegistrationLog {
  id          String    @id @default(uuid())
  websiteId   String
  userId      String?   // Who triggered this (if manual)
  
  // Registration attempt details
  isSuccess   Boolean
  errorCode   String?
  errorMessage String?  @db.Text
  stackTrace  String?   @db.Text
  
  // Performance metrics
  startTime   DateTime
  endTime     DateTime?
  duration    Int?      // Duration in milliseconds
  
  // Request/Response data
  requestData Json?     @db.JsonB
  responseData Json?    @db.JsonB
  
  // Tool information
  toolVersion String?
  toolName    String?
  ipAddress   String?
  userAgent   String?
  
  // Metadata
  metadata    Json?     @db.JsonB
  
  createdAt   DateTime  @default(now())
  
  // Relations
  website     Website   @relation(fields: [websiteId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id])
  
  @@index([websiteId])
  @@index([isSuccess])
  @@index([createdAt])
  @@index([startTime])
  @@map("registration_logs")
}

// ==================== STATISTICS ====================
model WebsiteStats {
  id          String    @id @default(uuid())
  websiteId   String
  userId      String?   // Stats per user (optional, null = system-level stats)

  // Time period for stats
  periodType  PeriodType
  periodStart DateTime
  periodEnd   DateTime

  // Success metrics
  totalAttempts    Int      @default(0)
  successCount     Int      @default(0)
  failureCount     Int      @default(0)
  successRate      Float    @default(0)

  // Performance metrics
  avgDuration      Float?   // Average duration in milliseconds
  minDuration      Float?
  maxDuration      Float?

  // Error tracking
  errorTypes       Json?    @db.JsonB // {"error_type": count}

  // Additional metrics
  metrics          Json?    @db.JsonB

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  website     Website   @relation(fields: [websiteId], references: [id], onDelete: Cascade)
  user        User?     @relation(fields: [userId], references: [id])

  // Note: Using separate index instead of unique constraint to support null userId
  @@index([websiteId, periodType, periodStart])
  @@index([websiteId])
  @@index([periodStart, periodEnd])
  // Additional composite indexes for statistics
  @@index([userId, periodType])
  @@index([periodType, periodStart])
  @@map("website_stats")
}

enum PeriodType {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  CUSTOM
}

// ==================== SYSTEM SETTINGS ====================
model SystemSetting {
  id        String   @id @default(uuid())
  key       String   @unique
  category  String?
  value     Json     @db.JsonB
  description String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("system_settings")
}

// ==================== AUDIT LOG ====================
model AuditLog {
  id          String   @id @default(uuid())
  userId      String?
  action      String   // CREATE, UPDATE, DELETE, etc.
  entity      String   // Website, User, etc.
  entityId    String?
  oldValues   Json?    @db.JsonB
  newValues   Json?    @db.JsonB
  ipAddress   String?
  userAgent   String?

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([entity, entityId])
  @@index([createdAt])
  // Composite indexes for statistics queries
  @@index([userId, createdAt])
  @@index([entity, createdAt])
  @@index([action, entity, createdAt])
  // Index for filtering by entityId with date range (used in getCTVIncomeStats, getCTVStatusChanges)
  @@index([entityId, createdAt])
  @@index([entity, action, entityId, createdAt])
  @@map("audit_logs")
}

// ==================== SERVICE REQUEST ====================
// Bảng gộp chung request của tất cả dịch vụ (Entity, Blog2, Podcast, Social, GG Stacking)
// Website KH gọi API insert vào bảng này, hệ thống sẽ tự động phân bổ
model ServiceRequest {
  id              String              @id @default(uuid())

  // External user (từ website KH - không có FK, vì user KH nằm ở hệ thống khác)
  externalUserId    String                              // ID user từ hệ thống KH
  externalUserEmail String?                             // Email user KH (để hiển thị)
  externalUserName  String?                             // Tên user KH (để hiển thị)

  // Internal user (nhân viên nội bộ Manager Site được gán xử lý)
  assignedUserId  String?
  assignedUser    User?               @relation(fields: [assignedUserId], references: [id])

  // Service identification
  serviceType     ServiceType                         // Loại dịch vụ
  serviceGroupId  String?                             // Liên kết Group bên website KH (socialGroupId, blogGroupId, podcastGroupId)
  externalId      String?                             // ID gốc của request bên website KH (để đồng bộ)

  // Tool assignment
  idTool          String?                             // Tool pair được phân bổ (e.g. "Normal 1;Captcha 1")

  // Request info
  name            String?
  typeRequest     String?                             // Loại request (post, register, ...)
  target          String?             @db.Text        // Mục tiêu / URL target
  auctionPrice    Decimal?            @db.Decimal(10, 2)

  // Status
  status          RequestStatus       @default(NEW)

  // Config riêng theo từng serviceType (lưu dưới dạng JSON)
  // Entity: { email, appPassword, username, entityLimit, accountType, spinContent, entityConnect, socialConnect, firstName, lastName, about, address, phone, location, website, fixedSites, avatar, cover }
  // Blog2:  { data }
  // Social: { data }
  // Podcast: { data }
  // GG Stacking: { folderUrl, title, website, about, phone, address, location, stackingConnect, spinContent, duplicate }
  config          Json?               @db.JsonB

  // Progress tracking
  totalLinks      Int                 @default(0)
  completedLinks  Int                 @default(0)
  failedLinks     Int                 @default(0)
  progressPercent Decimal             @default(0) @db.Decimal(5, 2)

  // Domain selection
  domains         DomainSelection     @default(LIKEPION)

  // Retry & run tracking
  retryCount      Int                 @default(0)
  runCount        Int                 @default(0)

  // Timestamps
  checkedAt       DateTime?
  deletedAt       DateTime?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations
  batches         AllocationBatch[]
  allocationItems AllocationItem[]

  @@index([status, serviceType])
  @@index([serviceType, deletedAt])
  @@index([externalUserId])
  @@index([assignedUserId])
  @@index([idTool])
  @@index([externalId, serviceType])
  @@index([status, deletedAt])
  @@index([createdAt])
  @@map("service_requests")
}

enum ServiceType {
  ENTITY
  BLOG2
  PODCAST
  SOCIAL
  GG_STACKING
}

enum RequestStatus {
  DRAFT         // KH tạo nhưng chưa gửi
  NEW           // KH vừa gửi, chờ hệ thống xử lý
  PENDING       // Đang chờ phân bổ website
  RUNNING       // Đã phân bổ, tool đang xử lý
  CONNECTING    // Tool đang kết nối/đăng ký
  COMPLETED     // Hoàn thành
  CANCEL        // Đã hủy
}

enum DomainSelection {
  LIKEPION
  LINKSBUFF
  ALL
  CUSTOM
}

// ==================== WEBSITE ALLOCATION ====================
// Batch phân bổ website cho mỗi ServiceRequest
model AllocationBatch {
  id                  String              @id @default(uuid())
  requestId           String?             // FK đến ServiceRequest
  externalRequestId   String?             // Legacy: ID của entity_request bên MySQL (sẽ bỏ sau khi migrate xong)
  batchNumber         Int                 // Số thứ tự batch (1, 2, 3...)

  // Allocation info
  targetCount         Int                 // Số website cần phân bổ trong batch này
  allocatedCount      Int                 @default(0)
  highTrafficCount    Int                 @default(0) // Số website traffic cao
  lowTrafficCount     Int                 @default(0) // Số website traffic thấp

  // Status
  status              AllocationBatchStatus @default(PENDING)

  // Timing
  startedAt           DateTime?
  completedAt         DateTime?

  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Relations
  request             ServiceRequest?     @relation(fields: [requestId], references: [id])
  items               AllocationItem[]

  @@unique([externalRequestId, batchNumber])
  @@index([requestId])
  @@index([externalRequestId])
  @@index([status])
  @@index([createdAt])
  @@map("allocation_batches")
}

enum AllocationBatchStatus {
  PENDING     // Chờ phân bổ
  PROCESSING  // Đang phân bổ
  COMPLETED   // Hoàn thành phân bổ
  FAILED      // Thất bại
}

// Chi tiết từng website được phân bổ + thông tin link (gộp vai trò entity_link, blog2_link, social_link...)
model AllocationItem {
  id              String              @id @default(uuid())
  batchId         String
  requestId       String?             // FK đến ServiceRequest (denormalized for performance)
  websiteId       String
  domain          String              // Domain website được phân bổ

  // Service type
  serviceType     ServiceType         // Loại dịch vụ (ENTITY, BLOG2, SOCIAL, PODCAST, GG_STACKING)

  // Allocation tracking
  trafficType     TrafficType         // HIGH hoặc LOW
  priorityScore   Float               @default(0) // Score dùng để sort (based on success rate)

  // Link info (tương ứng entity_link, blog2_link, social_link... bên MySQL)
  externalLinkId  String?             // ID của link bên MySQL (entity_link.id, blog2_link.id...)

  // Tool claim info
  claimedBy       String?             // Tool ID đã claim task này (id_tool)
  claimedAt       DateTime?           // Thời điểm claim
  claimTimeout    Int                 @default(5) // Timeout phút, sau đó task được release

  // Dữ liệu riêng theo từng serviceType (lưu dưới dạng JSONB)
  // Entity: { email, username, password, about }
  // Blog2:  { title, content, category, ... }
  // Social: { profileName, bio, ... }
  // Podcast: { channelName, description, ... }
  linkData        Json?               @db.JsonB

  // Kết quả từ tool (chung cho mọi service)
  linkProfile     String?             // URL profile đã tạo
  linkPost        String?             // URL bài đăng đã tạo

  // Status & tracking
  status          AllocationItemStatus @default(PENDING)
  linkStatus      String?             // Status gốc từ MySQL (new, registering, profiling, finish, failed...)
  retryIndex      Int                 @default(0) // Số lần retry (tương ứng entity_link.index)
  note            String?             @db.Text  // Ghi chú / lỗi chi tiết

  // Sync tracking
  resultSyncedAt  DateTime?           // Lần cuối sync kết quả từ MySQL

  // Error info
  errorCode       String?
  errorMessage    String?

  // Timestamps
  allocatedAt     DateTime            @default(now())
  completedAt     DateTime?

  // Relations
  batch           AllocationBatch     @relation(fields: [batchId], references: [id], onDelete: Cascade)
  request         ServiceRequest?     @relation(fields: [requestId], references: [id], onDelete: Cascade)
  website         Website             @relation(fields: [websiteId], references: [id], onDelete: Cascade)

  @@index([batchId])
  @@index([requestId])
  @@index([websiteId])
  @@index([status])
  @@index([serviceType])
  @@index([allocatedAt])
  @@index([externalLinkId])
  @@index([claimedBy])
  @@index([claimedAt])
  @@index([linkStatus])
  @@map("allocation_items")
}

enum TrafficType {
  HIGH    // >= 50k traffic
  LOW     // < 50k traffic
}

enum AllocationItemStatus {
  NEW               // Mới tạo, chờ tool claim
  REGISTERING       // Đang đăng ký tài khoản
  PROFILING         // Đang tạo profile
  CONNECT           // Chờ đủ điều kiện stacking (entityConnect=all/limit, đang chờ threshold)
  CONNECTING        // Đang thực hiện stacking (tool có thể claim)
  FAIL_REGISTERING  // Lỗi khi đăng ký
  FAIL_PROFILING    // Lỗi khi tạo profile
  FAIL_CONNECTING   // Lỗi khi kết nối
  CANCEL            // Đã hủy
  FINISH            // Hoàn thành

  // Legacy statuses (backward compatible)
  PENDING     // Deprecated - use NEW
  CLAIMED     // Deprecated - use REGISTERING/PROFILING/CONNECTING
  SUCCESS     // Deprecated - use FINISH
  FAILED      // Deprecated - use FAIL_*
  SKIPPED     // Bỏ qua
  CANCELLED   // Deprecated - use CANCEL
}

// ==================== DAILY ALLOCATION TRACKING ====================
// Track số lần website được phân bổ trong ngày
model DailyAllocation {
  id              String    @id @default(uuid())
  websiteId       String
  date            DateTime  @db.Date // Ngày (không có giờ)

  allocationCount Int       @default(0) // Số lần được phân bổ trong ngày
  successCount    Int       @default(0)
  failureCount    Int       @default(0)

  updatedAt       DateTime  @updatedAt

  @@unique([websiteId, date])
  @@index([websiteId])
  @@index([date])
  @@map("daily_allocations")
}

// ==================== SYSTEM ALERTS ====================
// Alert khi có vấn đề (timeout, tool offline, etc.)
model SystemAlert {
  id            String        @id @default(uuid())
  type          AlertType
  severity      AlertSeverity @default(WARNING)

  title         String
  message       String        @db.Text

  // Related entities
  entityType    String?       // Request, Tool, Website, etc.
  entityId      String?

  // Status
  isResolved    Boolean       @default(false)
  resolvedAt    DateTime?
  resolvedBy    String?

  metadata      Json?         @db.JsonB

  createdAt     DateTime      @default(now())

  @@index([type])
  @@index([severity])
  @@index([isResolved])
  @@index([createdAt])
  @@map("system_alerts")
}

enum AlertType {
  REQUEST_TIMEOUT     // Request quá deadline
  TOOL_OFFLINE        // Tool offline
  ALLOCATION_FAILED   // Phân bổ thất bại
  LOW_SUCCESS_RATE    // Tỷ lệ thành công thấp
  NO_AVAILABLE_TOOLS  // Không còn tool khả dụng
  SYSTEM_ERROR        // Lỗi hệ thống
}

enum AlertSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

// ==================== GMAIL MANAGEMENT ====================
model Gmail {
  id              String       @id @default(uuid())
  email           String       @unique
  password        String
  appPassword     String?      @map("app_password")
  twoFA           String?      @map("2fa")
  recoveryEmail   String?      @map("recovery_email")

  // Owner - người sở hữu gmail này (người đầu tiên sử dụng)
  ownerId         String?      @map("owner_id")
  owner           User?        @relation(fields: [ownerId], references: [id], onDelete: SetNull)

  // Status
  status          GmailStatus  @default(SUCCESS)

  // Timestamps
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  deletedAt       DateTime?    // Soft delete

  // Relations
  usages          GmailUsage[]

  @@index([email])
  @@index([ownerId])
  @@index([status])
  @@index([deletedAt])
  @@map("gmails")
}

// Track lịch sử sử dụng Gmail (mỗi lần export)
model GmailUsage {
  id          String   @id @default(uuid())
  gmailId     String   @map("gmail_id")
  userId      String   @map("user_id")

  // Timestamps
  usedAt      DateTime @default(now())

  // Relations
  gmail       Gmail    @relation(fields: [gmailId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([gmailId])
  @@index([userId])
  @@index([usedAt])
  @@map("gmail_usages")
}

enum GmailStatus {
  SUCCESS     // Thành công
  FAILED      // Thất bại
}

// ==================== TOOL MANAGEMENT ====================
model Tool {
  id              String          @id @default(uuid())

  // User relationship
  userId          String?         @map("user_id")
  user            User?           @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Tool info
  idTool          String          @map("id_tool")
  threadNumber    Int             @default(1) @map("thread_number")

  // Type & Status
  type            ToolType        @default(INDIVIDUAL)
  status          ToolStatus      @default(RUNNING)
  service         ToolService     @default(ENTITY)

  // Time tracking
  estimateTime    Int?            @map("estimate_time") // Thời gian ước tính (phút/giây)

  // Customer info
  customerType    String?         @map("customer_type")

  // Timestamps
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  deletedAt       DateTime?       // Soft delete

  @@index([userId])
  @@index([idTool])
  @@index([type])
  @@index([status])
  @@index([service])
  @@index([deletedAt])
  @@map("tools")
}

enum ToolType {
  INDIVIDUAL    // Cá nhân
  GLOBAL        // Toàn cục
  CANCEL        // Hủy
  RE_RUNNING    // Chạy lại
}

enum ToolStatus {
  RUNNING       // Đang chạy
  DIE           // Chết/Dừng
}

enum ToolService {
  ENTITY          // Entity
  SOCIAL          // Social
  INDEX           // Index
  GOOGLE_STACKING // Google Stacking
  BLOG            // Blog
  PODCAST         // Podcast
}

// ==================== PROXY MANAGEMENT ====================
model Proxy {
  id              String          @id @default(uuid())

  // Connection info
  ip              String
  port            Int
  username        String?
  password        String?

  // Type & Protocol
  type            ProxyType       @default(IPV4_STATIC)
  protocol        ProxyProtocol   @default(HTTP)

  // Services this proxy is used for
  services        ProxyServiceType[] @default([])

  // Status & Health
  status          ProxyStatus     @default(UNKNOWN)
  lastCheckedAt   DateTime?       @map("last_checked_at")
  responseTime    Int?            @map("response_time") // in milliseconds
  failCount       Int             @default(0) @map("fail_count")

  // Location
  country         String?         @db.VarChar(2)

  // Notes
  note            String?         @db.Text

  // Timestamps
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  deletedAt       DateTime?       @map("deleted_at")

  @@unique([ip, port])
  @@index([deletedAt])
  @@index([type])
  @@index([protocol])
  @@index([status])
  @@index([services])
  @@index([createdAt])
  @@map("proxies")
}

enum ProxyType {
  IPV4_STATIC     // Proxy IPv4 tĩnh
  IPV6_STATIC     // Proxy IPv6 tĩnh
  SOCKS5          // Proxy SOCKS5
  ROTATING        // Proxy xoay
}

enum ProxyProtocol {
  HTTP
  HTTPS
  SOCKS4
  SOCKS5
}

enum ProxyStatus {
  ACTIVE          // Hoạt động tốt
  DEAD            // Chết/Không hoạt động
  CHECKING        // Đang kiểm tra
  UNKNOWN         // Chưa kiểm tra
}

enum ProxyServiceType {
  ENTITY          // Entity
  BLOG_2_0        // Blog 2.0
  PODCAST         // Podcast
  SOCIAL          // Social
  GG_STACKING     // GG Stacking
}

// ==================== SYSTEM CONFIGURATION ====================
// Lưu các config có thể điều chỉnh mà không cần sửa code
model SystemConfig {
  id          String    @id @default(uuid())
  key         String    @unique // Key duy nhất, ví dụ: ALLOCATION_MULTIPLIER
  value       String    // Giá trị (string, parse theo type khi dùng)
  type        ConfigType @default(STRING) // Loại dữ liệu để parse
  description String?   @db.Text // Mô tả config

  // Metadata
  updatedBy   String?   // User ID người cập nhật cuối
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([key])
  @@map("system_configs")
}

enum ConfigType {
  STRING
  NUMBER
  BOOLEAN
  JSON
}